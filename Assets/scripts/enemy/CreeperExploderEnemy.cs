using UnityEngine;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// Minecraft Creeper-style enemy. Approaches player, starts hissing/flashing when close,
/// explodes if player stays in range — cancels if player escapes.
/// 
/// Auto-detects child parts (Sphere, Cones, Antennae, Legs, OuterShell, InnerShell)
/// and pulses them white during fuse. Uses direct material color swap (reliable in URP).
/// 
/// Attach to prefab root "CreeperExploder".
/// </summary>
public class CreeperExploderEnemy : EnemyBase
{
    [Header("Creeper Ranges")]
    [SerializeField] private float armRadius = 5f;
    [SerializeField] private float explosionRadius = 7f;

    [Header("Fuse")]
    [SerializeField] private float fuseTime = 2.5f;

    [Header("Explosion")]
    [SerializeField] private int explosionDamage = 40;
    [SerializeField] private float knockbackForce = 18f;

    [Header("Movement")]
    [SerializeField] private float moveSpeed = 4.5f;
    [SerializeField] private float turnSpeed = 5f;

    [Header("VFX Prefabs (from asset store)")]
    [SerializeField] private GameObject explosionVfxPrefab;   // vfx_Explosion_01
    [SerializeField] private GameObject fuseWarningVfxPrefab;  // vfx_Electricity_01 or vfx_Sparks_01

    [Header("Flash Colors")]
    [SerializeField] private Color normalColor = new Color(0.2f, 0.75f, 0.2f, 1f);
    [SerializeField] private Color flashWhite = Color.white;

    // ── State machine ──
    private enum CreeperState { Idle, Chase, Fusing }
    private CreeperState state = CreeperState.Idle;

    // ── Components ──
    private Rigidbody rb;

    // ── Fuse tracking ──
    private float fuseTimer;
    private bool hasExploded;
    private GameObject activeWarningVfx;

    // ── Visual parts ──
    private Renderer[] partRenderers;
    private List<Material> allMaterials;   // actual instanced material refs (not copies)
    private Color[] originalColors;

    // ═══════════════════════════════════════════
    //  INIT
    // ═══════════════════════════════════════════

    protected override void Awake()
    {
        // Creeper is fragile - 1 sword hit (10 dmg) kills it
        maxHealth = 10;
        
        base.Awake();

        rb = GetComponent<Rigidbody>();
        if (rb == null)
            rb = gameObject.AddComponent<Rigidbody>();
        rb.useGravity = false;
        rb.freezeRotation = true;
        rb.collisionDetectionMode = CollisionDetectionMode.Continuous;

        // Collect every renderer in the hierarchy and instance their materials
        CollectRenderers();
    }

    private void CollectRenderers()
    {
        Renderer[] allRenderers = GetComponentsInChildren<Renderer>(true); // include inactive children

        // Filter out health bar quads (auto-generated by EnemyBase)
        List<Renderer> filtered = new List<Renderer>();
        foreach (Renderer r in allRenderers)
        {
            if (r == null) continue;
            if (r.gameObject.name.StartsWith("HP_")) continue; // skip health bar pieces
            filtered.Add(r);
        }
        partRenderers = filtered.ToArray();

        allMaterials = new List<Material>();
        List<Color> cols = new List<Color>();

        foreach (Renderer r in partRenderers)
        {
            if (r == null) continue;

            // ── KEY FIX: reading .materials creates instanced copies that we OWN ──
            // We then write them back so the renderer actually uses these instances.
            Material[] instancedMats = r.materials; // creates instances
            r.materials = instancedMats;            // assign back so renderer uses them

            foreach (Material m in instancedMats)
            {
                allMaterials.Add(m);

                // Enable emission keyword so _EmissionColor actually works in URP
                m.EnableKeyword("_EMISSION");

                // Cache the original color
                if (m.HasProperty("_BaseColor"))
                    cols.Add(m.GetColor("_BaseColor"));
                else if (m.HasProperty("_Color"))
                    cols.Add(m.GetColor("_Color"));
                else
                    cols.Add(Color.white);
            }
        }

        originalColors = cols.ToArray();
        Debug.Log($"[{gameObject.name}] Creeper: collected {partRenderers.Length} renderers, {allMaterials.Count} materials for flash.");
    }

    // ═══════════════════════════════════════════
    //  UPDATE / STATE MACHINE
    // ═══════════════════════════════════════════

    protected override void Update()
    {
        if (isDead || hasExploded) return;
        base.Update();

        switch (state)
        {
            case CreeperState.Idle:   IdleState();   break;
            case CreeperState.Chase:  ChaseState();  break;
            case CreeperState.Fusing: FusingState(); break;
        }
    }

    private void IdleState()
    {
        rb.linearVelocity = Vector3.Lerp(rb.linearVelocity, Vector3.zero, Time.deltaTime * 2f);
        if (playerDetected)
            state = CreeperState.Chase;
    }

    private void ChaseState()
    {
        if (playerTransform == null) { state = CreeperState.Idle; return; }

        float dist = DistanceToPlayer();

        // Lost player
        if (!playerDetected && dist > loseRadius)
        {
            state = CreeperState.Idle;
            return;
        }

        // Close enough → start fuse
        if (dist <= armRadius)
        {
            StartFuse();
            return;
        }

        // Move toward player
        Vector3 dir = (playerTransform.position - transform.position).normalized;
        Quaternion look = Quaternion.LookRotation(dir);
        transform.rotation = Quaternion.Slerp(transform.rotation, look, Time.deltaTime * turnSpeed);

        Vector3 vel = dir * moveSpeed;
        rb.linearVelocity = Vector3.Lerp(rb.linearVelocity, vel, Time.deltaTime * 3f);
        rb.linearVelocity = Vector3.ClampMagnitude(rb.linearVelocity, moveSpeed * 1.2f);
    }

    // ═══════════════════════════════════════════
    //  FUSE (ARMING)
    // ═══════════════════════════════════════════

    private void StartFuse()
    {
        state = CreeperState.Fusing;
        fuseTimer = fuseTime;

        if (fuseWarningVfxPrefab != null)
            activeWarningVfx = Instantiate(fuseWarningVfxPrefab, transform.position, Quaternion.identity, transform);
    }

    private void FusingState()
    {
        if (playerTransform == null) { CancelFuse(); return; }

        float dist = DistanceToPlayer();

        // ── Player escaped! Stop everything, back to chase. ──
        if (dist > armRadius * 1.3f)
        {
            CancelFuse();
            return;
        }

        // Lock in place
        rb.linearVelocity = Vector3.Lerp(rb.linearVelocity, Vector3.zero, Time.deltaTime * 8f);

        // Face player
        Vector3 dir = (playerTransform.position - transform.position).normalized;
        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(dir), Time.deltaTime * turnSpeed);

        // Countdown
        fuseTimer -= Time.deltaTime;
        float progress = 1f - Mathf.Clamp01(fuseTimer / fuseTime); // 0 → 1

        // ── FLASH: frequency ramps from 4Hz to 20Hz ──
        float freq = Mathf.Lerp(4f, 20f, progress);
        float pulse = (Mathf.Sin(Time.time * freq * Mathf.PI) + 1f) * 0.5f;
        // Bias toward white as fuse nears completion
        pulse = Mathf.Lerp(pulse, 1f, progress * 0.4f);

        ApplyFlashToAllMaterials(pulse);

        // BOOM
        if (fuseTimer <= 0f)
            Explode();
    }

    private void CancelFuse()
    {
        state = CreeperState.Chase;
        fuseTimer = 0f;

        if (activeWarningVfx != null)
        {
            Destroy(activeWarningVfx);
            activeWarningVfx = null;
        }

        // Restore original colors — no pulsing, no white
        RestoreAllMaterials();
    }

    // ═══════════════════════════════════════════
    //  EXPLOSION
    // ═══════════════════════════════════════════

    private void Explode()
    {
        if (hasExploded) return;
        hasExploded = true;
        isDead = true;

        // Disable collider so it doesn't interact during animation
        Collider col = GetComponent<Collider>();
        if (col != null) col.enabled = false;
        if (rb != null) rb.linearVelocity = Vector3.zero;

        // AOE damage + knockback (deal immediately so player feels the hit)
        DealExplosionDamage();

        // Kill warning VFX
        if (activeWarningVfx != null)
        {
            Destroy(activeWarningVfx);
            activeWarningVfx = null;
        }

        // Start smooth explosion sequence
        StartCoroutine(ExplodeSequence());
    }

    private IEnumerator ExplodeSequence()
    {
        Vector3 originalScale = transform.localScale;

        // Phase 1: Quick swell up + flash bright white (0.15s)
        float swellTime = 0.15f;
        float elapsed = 0f;
        while (elapsed < swellTime)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / swellTime;
            // Swell to 1.3x size
            transform.localScale = originalScale * (1f + t * 0.3f);
            // Flash to solid white
            SetAllMaterialsColor(Color.Lerp(originalColors.Length > 0 ? originalColors[0] : normalColor, flashWhite, t));
            yield return null;
        }

        // Phase 2: Hold bright white for a beat (0.05s)
        SetAllMaterialsColor(flashWhite);
        yield return new WaitForSeconds(0.05f);

        // Phase 3: Spawn explosion VFX at peak
        if (explosionVfxPrefab != null)
        {
            GameObject vfx = Instantiate(explosionVfxPrefab, transform.position, Quaternion.identity);
            Destroy(vfx, 4f);
        }

        // Phase 4: Rapid scale down + fade out (0.15s)
        elapsed = 0f;
        float shrinkTime = 0.15f;
        while (elapsed < shrinkTime)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / shrinkTime;
            // Shrink to nothing
            transform.localScale = originalScale * 1.3f * (1f - t);
            // Fade emission out
            float fade = 1f - t;
            SetAllMaterialsColor(flashWhite * fade);
            yield return null;
        }

        // Fully destroy — strip ragdoll so base class can't delay it
        var ragdoll = GetComponent<EnemyRagdollActivator>();
        if (ragdoll != null) Destroy(ragdoll);

        Destroy(gameObject);
    }

    private void DealExplosionDamage()
    {
        Collider[] hits = Physics.OverlapSphere(transform.position, explosionRadius);

        foreach (Collider col in hits)
        {
            PlayerHealth hp = col.GetComponent<PlayerHealth>();
            if (hp != null)
                hp.TakeDamage(explosionDamage);

            // Knockback via CharacterController system (same as RockCharger)
            PlayerMovement pm = col.GetComponent<PlayerMovement>();
            if (pm != null)
            {
                Vector3 knockDir = (col.transform.position - transform.position).normalized;
                pm.ApplyKnockback(knockDir, knockbackForce);
            }
        }
    }

    // ═══════════════════════════════════════════
    //  MATERIAL COLOR CONTROL (direct on instanced materials)
    // ═══════════════════════════════════════════

    private void ApplyFlashToAllMaterials(float t)
    {
        for (int i = 0; i < allMaterials.Count && i < originalColors.Length; i++)
        {
            Material m = allMaterials[i];
            if (m == null) continue;

            Color lerped = Color.Lerp(originalColors[i], flashWhite, t);

            if (m.HasProperty("_BaseColor"))
                m.SetColor("_BaseColor", lerped);
            if (m.HasProperty("_Color"))
                m.SetColor("_Color", lerped);
            if (m.HasProperty("_EmissionColor"))
                m.SetColor("_EmissionColor", lerped * t * 2f);
        }
    }

    private void RestoreAllMaterials()
    {
        for (int i = 0; i < allMaterials.Count && i < originalColors.Length; i++)
        {
            Material m = allMaterials[i];
            if (m == null) continue;

            if (m.HasProperty("_BaseColor"))
                m.SetColor("_BaseColor", originalColors[i]);
            if (m.HasProperty("_Color"))
                m.SetColor("_Color", originalColors[i]);
            if (m.HasProperty("_EmissionColor"))
                m.SetColor("_EmissionColor", Color.black);
        }
    }

    private void SetAllMaterialsColor(Color color)
    {
        for (int i = 0; i < allMaterials.Count; i++)
        {
            Material m = allMaterials[i];
            if (m == null) continue;

            if (m.HasProperty("_BaseColor"))
                m.SetColor("_BaseColor", color);
            if (m.HasProperty("_Color"))
                m.SetColor("_Color", color);
            if (m.HasProperty("_EmissionColor"))
                m.SetColor("_EmissionColor", color * 2f);
        }
    }

    // ═══════════════════════════════════════════
    //  DEATH (killed before explosion)
    // ═══════════════════════════════════════════

    protected override void Die()
    {
        if (hasExploded) return;
        if (isDead) return;
        isDead = true;

        if (rb != null) rb.linearVelocity = Vector3.zero;

        // Stop any fusing
        StopAllCoroutines();

        if (activeWarningVfx != null)
        {
            Destroy(activeWarningVfx);
            activeWarningVfx = null;
        }

        RestoreAllMaterials();

        // Remove ragdoll so base class can't delay destruction
        var ragdoll = GetComponent<EnemyRagdollActivator>();
        if (ragdoll != null) Destroy(ragdoll);

        // Fully destroy entire gameObject immediately (health bar is child, destroyed too)
        Destroy(gameObject);
    }

    // ═══════════════════════════════════════════
    //  GIZMOS
    // ═══════════════════════════════════════════

    protected override void OnDrawGizmosSelected()
    {
        base.OnDrawGizmosSelected();

        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, armRadius);

        Gizmos.color = Color.magenta;
        Gizmos.DrawWireSphere(transform.position, explosionRadius);
    }
}